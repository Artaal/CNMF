# -*- coding: utf-8 -*-
"""CNMF.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10zY5XdLQHMDvoa8WiXwaG9Sqv6YhoLkr

# **Méthode de fusion CNMF basée sur la Factorisation en Matrices Non-négatives**![Capture.PNG](data:image/png;base64,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)

> Bloc en retrait

**Thèse dont la méthode est extraite :**
 https://tel.archives-ouvertes.fr/tel-01204977/document

# Librairies

**hypers** Provides a data structure model for hyperspectral data.

• Simple tools for exploratory analysis of hyperspectral data

• Interactive hyperspectral viewer built into the object

• Allows for unsupervised machine learning directly on the object (using scikit-learn)
"""

pip install rasterio

pip install hypers

# Commented out IPython magic to ensure Python compatibility.
# Import required packages and libraries :

import numpy as np
import hypers as hp
from hypers.learning.decomposition import vca # vertex component analysis
from PIL.Image import *
from PIL import Image
import matplotlib.pyplot as plt
import random
import cv2
from itertools import combinations
import rasterio
from rasterio import plot
# %matplotlib inline

"""# **Algorithme de fusion CNMF**

## Etape 1
"""

# W et H  sont optimisés avec (3.10) et (3.11) : 
# note : for np.dot, the height of the first matrix has to be equal to the width of the second

def optimiser(X,W,H, epsilon = 1e-5, verbose = True ,max_iterations_without_improv = 200):
  cout_prev = np.linalg.norm(X - np.dot(W,H)) # previous cost
  cout_rec = cout_prev - 2* epsilon   # recent cost
  i = 0
  # best_values = {}
  min_cout = 10
  miwi = 0
  while cout_rec!= 0 and abs((cout_prev - cout_rec)/cout_rec) > epsilon/1000 :  # critère d'arrêt (3.21)
    W = W * np.dot(X,H.T)/np.dot(W,np.dot(H,H.T)) # (3.10)
    H = H * np.dot(W.T,X)/np.dot(W.T,np.dot(W,H)) # (3.11)
    cout_prev = cout_rec
    cout_rec = np.linalg.norm(X - np.dot(W,H))
    if cout_rec < min_cout :
      miwi = 0
      min_cout = cout_rec
    else :
      miwi += 1
    if miwi == max_iterations_without_improv : 
      print('You reach max iterations without improvements (optimiser)')
      break

    if verbose and i%1000 == 0 :
      print("itération (optimiser) ", i , ":" , cout_rec)
    i += 1

  if verbose : print("itération finale (optimiser) :" , cout_rec)
  return W,H,min_cout

def Etape1(Lambda_x,Lx,X) :
 
  # Wx est initialisé en utilisant l’algorithme VCA (Vertex Component Analysis)
  Wx_i = np.random.rand(Lambda_x, Lambda_x)
  Wx_h = hp.array(Wx_i)
  vca_Wx = vca(Wx_h)
  res = vca_Wx.calculate(n_components)
  Wx = res[0]

  # Hx est estimé par (3.11)
  Hx = np.random.rand(n_components,Lx)
  Hx = Hx * np.dot(Wx.T,X)/np.dot(Wx.T,np.dot(Wx,Hx)) # (3.11)

  # Wx et Hx sont optimisés avec (3.10) et (3.11).
  Wx, Hx , cout_x = optimiser(X,Wx,Hx , epsilon = eps , verbose = True)

  return Wx, Hx , cout_x

"""## Etape 2"""

def Etape2(R,Wx,Hy,Y ,verbose = True):
 
  # Wy est déduite de Wx
  Wy = np.dot(R,Wx)

  # Hy est estimée par (3.11)
  Hy = Hy * np.dot(Wy.T,Y)/np.dot(Wy.T,np.dot(Wy,Hy))

  # Wy et Hy sont alors optimisés par (3.10) et (3.11)
  Wy, Hy , cout_y  = optimiser(Y,Wy,Hy , epsilon = eps ,verbose = verbose)

  return Wy, Hy , cout_y

"""## Etape 3"""

def Etape3(Hy,S,Wx,X , verbose = True) :
  # Hx est déduite de Hy par (3.18) :
  Hx = np.dot(Hy,S) 

  # Wx est ré-estimée par (3.10)
  Wx = Wx * np.dot(X,Hx.T)/np.dot(Wx,np.dot(Hx,Hx.T)) #(3.10)

  # Wx et Hx sont optimisés avec (3.10) et (3.11).
  Wx, Hx , cout_x  = optimiser(X,Wx,Hx , epsilon = eps ,verbose = verbose)
  
  return Wx, Hx , cout_x

"""## Etape 4"""

def Etape4(cout_x , cout_y ,R,Wx,Hy,Y,S,X, epsilon = 1e-10,verbose = True ,max_iterations_without_improv = 25):
  cout_moyen_prev = (cout_x + cout_y)/2 # previous mean cost
  cout_moyen_rec = cout_moyen_prev - 2*epsilon # recent mean cost
  i = 0
  best_values = {}
  best_values['cout_moyen'] = 10
  miwi = 0 
  while cout_moyen_rec!= 0 and abs((cout_moyen_prev - cout_moyen_rec)/cout_moyen_rec) > 2*epsilon :   # condition d'arrêt 
    Wy, Hy , cout_y = Etape2(R,Wx,Hy,Y,verbose = False)
    Wx, Hx , cout_x  = Etape3(Hy,S,Wx,X,verbose = False)

    cout_moyen_prev = cout_moyen_rec
    cout_moyen_rec = (cout_x + cout_y)/2
    

    if cout_moyen_rec < best_values['cout_moyen'] :
      best_values['cout_moyen'] = cout_moyen_rec
      best_values['Wx'],best_values['Hx']  = Wx ,Hx
      best_values['Wy'],best_values['Hy']  = Wy ,Hy
      miwi = 0

    else : 
      miwi += 1

    if miwi == max_iterations_without_improv : 
      print('You reach max iterations without improvements (step 4)')
      break

    if verbose and i% 50000 == 0 :
      print("itération (step 4)", i , ":" , cout_moyen_rec)
    i += 10
    #print('miwi ', miwi)
  if verbose : print("itération finale : (step 4)" , cout_moyen_rec)
  return best_values

"""## Etape 5"""

Wx = best_values['Wx']
Hy = best_values['Hy']
Z = np.dot(Wx,Hy)
# Z , Z.shape
print(Z)
plt.imshow(Z)

"""## Test section

### Creation and split of X
"""

# Useful function to normalize our matrix for the calculs :

def normalize(mat):
  siz = mat.shape
  mat_norm = np.empty(siz)
  max = 0
  min = 255
  for i in range(siz[0]):
    for j in range(siz[1]):
      if mat[i,j] > max :
        max = mat[i,j]
      if mat[i,j] < min :
        min = mat[i,j]
  eps = max - min
  for i in range(siz[0]):
    for j in range(siz[1]):
      mat_norm[i,j] = (mat[i,j] - min)/eps
  return mat_norm

from google.colab import drive
drive.mount('/content/drive')

# Import of our virtual hyperspectral image :

dir_hs = '/content/drive/MyDrive/Stage_2022_ACRI-ST/fusion/data/data_for_test/Test_MS.jpg'
im_hs = Image.open(dir_hs)
mat_hyp = np.array(im_hs)

# Visualization of our image :

fig = plt.figure(figsize=(15,15))
fig.add_subplot(1, 1, 1)
plt.imshow(mat_hyp)

print('shape of mat_hs :\n' ,mat_hyp.shape)

# Now we create our green, red and blue bands of this image : 

b_band_hs = cv2.split(mat_hyp)[0]
g_band_hs = cv2.split(mat_hyp)[1]
r_band_hs = cv2.split(mat_hyp)[2]

fig = plt.figure(figsize=(15,15))
fig.add_subplot(1, 3, 3)
plt.imshow(b_band_hs)
plt.title("Blue band : ", size = 30)
print("Size :", (mat_hyp.shape[0],mat_hyp.shape[1]))

fig.add_subplot(1, 3, 2)
plt.imshow(g_band_hs)
plt.title("Green band : ", size = 30)
print("Size :", (mat_hyp.shape[0],mat_hyp.shape[1])) 

fig.add_subplot(1, 3, 1)
plt.imshow(r_band_hs)
plt.title("Red band : ", size = 30)
print("Size :", (mat_hyp.shape[0],mat_hyp.shape[1]))

# Now we unfold our matrixes in order to apply the CNMF algorithm :

r_band_hs_flat = r_band_hs.flatten()
g_band_hs_flat = g_band_hs.flatten()
b_band_hs_flat = b_band_hs.flatten()
image_hs = []
image_hs.append(r_band_hs_flat)
image_hs.append(g_band_hs_flat)
image_hs.append(b_band_hs_flat)

image_hs = np.array(image_hs)
image_hs = normalize(image_hs)

for i in range(3):
  for j in range(len(image_hs[0])):
    if(image_hs[i][j]) == 1. : image_hs[i][j] = 0.99999
    if(image_hs[i][j]) == 0. : image_hs[i][j] = 0.00005
    
image_hs
# We have our unfolded matrix for the hyperpsectral data !

"""### Creation and split of Y"""

# import of our virtual multispectral image :

dir_ms = '/content/drive/MyDrive/Stage_2022_ACRI-ST/fusion/data/data_for_test/Test_Pan.jpg'
im_ms = Image.open(dir_ms)
mat_ms = np.array(im_ms)

(largeur, hauteur)= im_ms.size

# visualization of our image :

fig = plt.figure(figsize=(15,15))
fig.add_subplot(1, 1, 1)
plt.imshow(mat_ms)

print('shape of mat_ms :\n' ,mat_ms.shape)

# We visualize the 3 bands : 

b_band_ms = cv2.split(mat_ms)[0]
g_band_ms = cv2.split(mat_ms)[1]
r_band_ms = cv2.split(mat_ms)[2]

fig = plt.figure(figsize=(15,15))
fig.add_subplot(1, 3, 3)
plt.imshow(b_band_ms)
plt.title("Blue band : ", size = 30)
print("Size :", (mat_ms.shape[0],mat_ms.shape[1])) 

fig.add_subplot(1, 3, 2)
plt.imshow(g_band_ms)
plt.title("Green band : ", size = 30)
print("Size :", (mat_ms.shape[0],mat_ms.shape[1])) 

fig.add_subplot(1, 3, 1)
plt.imshow(r_band_ms)
plt.title("Red band : ", size = 30)
print("Size :", (mat_ms.shape[0],mat_ms.shape[1]))

# Now we unfold our matrixes in order to apply the CNMF algorithm :

r_band_ms_flat = r_band_ms.flatten()
g_band_ms_flat = g_band_ms.flatten()
b_band_ms_flat = b_band_ms.flatten()
image_ms = []
image_ms.append(r_band_ms_flat)
image_ms.append(g_band_ms_flat)
image_ms.append(b_band_ms_flat)

image_ms = np.array(image_ms)
image_ms = normalize(image_ms)

# for i in range(3):
for j in range(len(image_ms[0])):
    if(image_ms[0][j]) == 1. : image_ms[0][j] = 0.9999
    if(image_ms[0][j]) == 0. : image_ms[0][j] = 0.0005

image_ms

# We have our unfolded matrix for the multispectral data !

"""### Implementation of the Algorithme

#### Parameters
"""

######## Critère de précision : #########
eps = 1e-2

# Parameters of Etape 1 :

# hyp = unfold(r_sub_matrix_hs,g_sub_matrix_hs)
Lambda_x = image_hs.shape[0]
Lx = image_hs.shape[1]
n_components = 3

# Parameters of Etape 2 :

Lambda_y = image_ms.shape[0]
Ly = image_ms.shape[1]
R = np.random.rand(Lambda_y, Lambda_x)
S = np.random.rand(Ly, Lx)
Hy = np.random.rand(n_components, Ly)

print( "Parameters :\n\nLambda_x :", Lambda_x, "\nLx :",Lx, "\nn_components :", n_components, "\nLambda_y :", Lambda_y, "\nLy :",Ly, "\nR :\n", R, "\nS :\n", S, "\nHy :\n", Hy,"\n\nCritère de précision :\n", eps)

"""#### Algorithme"""

def Algo_CNMF(Lambda_x,Lx,X,R,S,Hy,Y,steps = True):
  verbose = steps
  Wx, Hx , cout_x = Etape1(Lambda_x,Lx,X)
  Wy, Hy , cout_y = Etape2(R,Wx,Hy,Y,verbose)
  Wx, Hx , cout_x  = Etape3(Hy,S,Wx,X ,verbose)

  best_values = Etape4(cout_x , cout_y ,R,Wx,Hy,Y,S,X, epsilon = eps,verbose =steps, max_iterations_without_improv = 15)
  Wx = best_values['Wx']
  Hy = best_values['Hy']
  Z = np.dot(Wx,Hy)
  return Z,Wx,Hy,cout_x,cout_y

def Algo_CNMF_v2(Lambda_x,Lx,X,R,S,Hy,Y,Wx,cout_x,cout_y,steps = True) :
  verbose = steps
  best_values = Etape4(cout_x , cout_y ,R,Wx,Hy,Y,S,X, epsilon = eps,verbose =steps, max_iterations_without_improv = 15)
  Wx = best_values['Wx']
  Hy = best_values['Hy']
  Z = np.dot(Wx,Hy)
  return Z,Wx,Hy,cout_x,cout_y

# Test :
Z_final = Algo_CNMF(Lambda_x,Lx,image_hs,R,S,Hy,image_ms, steps = True)

# Test 2:
Z_final_2 = Algo_CNMF_v2(Lambda_x,Lx,image_hs,R,S,Z_final[2],image_ms,Z_final[1],Z_final[3], Z_final[4],steps = True)

# Reconstitution of our final image : 

# We reshape our colors matrix :

len_0 = Z_final[0].shape[0]
len_1 = mat_ms.shape[0]
len_2 = mat_ms.shape[1]
mat_final_red = Z_final[0][0].reshape(len_1,len_2)
mat_final_green = Z_final[0][1].reshape(len_1,len_2)
mat_final_blue = Z_final[0][2].reshape(len_1,len_2)

fact_red = 255/(np.max(Z_final[0][0]))
fact_green = 255/(np.max(Z_final[0][1]))
fact_blue = 255/(np.max(Z_final[0][2]))

mat_finale = np.empty((len_1,len_2,3))
for i in range(len_1):
  for j in range(len_2):
    mat_finale[i][j][0] = mat_final_red[i][j]*fact_red
    mat_finale[i][j][1] = mat_final_green[i][j]*fact_green
    mat_finale[i][j][2] = mat_final_blue[i][j]*fact_blue
mat_finale = mat_finale.astype('uint8') 
fig = plt.figure(figsize=(15,15))
fig.add_subplot(1,1,1)
plt.imshow(mat_finale)
print(" /!\ Before denoising :")

# The 3 bands obtained are : 

mat_res_blue = cv2.split(mat_finale)[0]
mat_res_green = cv2.split(mat_finale)[1]
mat_res_red = cv2.split(mat_finale)[2]

fig = plt.figure(figsize=(30,30))
fig.add_subplot(1, 3, 3)
plt.imshow(mat_res_blue)
plt.title("Blue band : ", size = 30)

fig.add_subplot(1, 3, 2)
plt.imshow(mat_res_green)
plt.title("Green band : ", size = 30)

fig.add_subplot(1, 3, 1)
plt.imshow(mat_res_red)
plt.title("Red band : ", size = 30)
print(" /!\ Before denoising :")

denoised_image_color = cv2.fastNlMeansDenoisingColored(mat_finale,None,10,10,7,21)
fig = plt.figure(figsize=(15,15))
plt.imshow(denoised_image_color)

"""######**Another approach :**"""

# another approach :

# We will apply the cnmf on each color :

b_band = image_hs[2]
b_band_final = []
b_band_final.append(b_band)
b_band_final.append(b_band)
b_band_final.append(b_band)
b_band_final = np.array(b_band_final)

g_band = image_hs[1]
g_band_final = []
g_band_final.append(g_band)
g_band_final.append(g_band)
g_band_final.append(g_band)
g_band_final = np.array(g_band_final)

r_band = image_hs[0]
r_band_final = []
r_band_final.append(r_band)
r_band_final.append(r_band)
r_band_final.append(r_band)
r_band_final = np.array(r_band_final)

######## Critère de précision : #########
eps = 1e-5
# Parameters of Etape 1 :

# hyp = unfold(r_sub_matrix_hs,g_sub_matrix_hs)
Lambda_x = r_band_final.shape[0]
Lx = r_band_final.shape[1]
n_components = 3

# Parameters of Etape 2 :

Lambda_y = Ly = image_ms.shape[0]
Ly = image_ms.shape[1]
R = np.random.rand(Lambda_y, Lambda_x)
S = S
Hy = np.random.rand(n_components, Ly)

print( "Parameters :\n\nLambda_x :", Lambda_x, "\nLx :",Lx, "\nn_components :", n_components, "\nLambda_y :", Lambda_y, "\nLy :",Ly, "\nR :\n", R, "\nS :\n", S, "\nHy :\n", Hy,"\n\nCritère de précision :\n", eps)

# Test :
Z_r_band = Algo_CNMF(Lambda_x,Lx,r_band_final,R,S,Hy,image_ms, steps = True)

# Test :
Z_g_band = Algo_CNMF(Lambda_x,Lx,g_band_final,R,S,Hy,image_ms, steps = True)

# Test :
Z_b_band = Algo_CNMF(Lambda_x,Lx,b_band_final,R,S,Hy,image_ms, steps = True)

len_1 = mat_ms.shape[0]
len_2 = mat_ms.shape[1]

# The 3 bands obtained are : 
fig = plt.figure(figsize=(30,30))
fig.add_subplot(1, 3, 3)
mat_res_blue_final = Z_b_band[0][0].reshape(len_1,len_2)
plt.imshow(mat_res_blue_final)
plt.title("Blue band : ", size = 30)

fig.add_subplot(1, 3, 2)
mat_res_green_final = Z_g_band[0][0].reshape(len_1,len_2)
plt.imshow(mat_res_green_final)
plt.title("Green band : ", size = 30)

fig.add_subplot(1, 3, 1)
mat_res_red_final = Z_r_band[0][0].reshape(len_1,len_2)
plt.imshow(mat_res_red_final)
plt.title("Red band : ", size = 30)
print(" /!\ Before denoising :")

liste = [1,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2,2.1,2.2,2.3,2.4,2.5,2.6,2.7,2.8,2.9,3]
temp = combinations(liste, 3)
liste_combo = list(temp)
len(liste_combo)

n = len(liste_combo)
res = []
fig = plt.figure(figsize=(400,400))
for k in range(n):
  mat_final = np.empty((len_1,len_2,3))
  for i in range(len_1):
    for j in range(len_2):
      mat_final[i][j][0] = mat_res_red_final[i][j]*255*1e4*liste_combo[k][0]
      mat_final[i][j][1] = mat_res_green_final[i][j]*255*1e4*liste_combo[k][1]
      mat_final[i][j][2] = mat_res_blue_final[i][j]*255*1e4*liste_combo[k][2]
  mat_final = mat_final.astype('uint8')
  res.append(mat_final) 
  # fig.add_subplot(n//3+5,3,k+1)
  # plt.imshow(mat_final)
  # plt.title(liste_combo[k])

nb = 51*1
nb2 = nb+51
fig = plt.figure(figsize=(40,40))
for i in range(nb,nb2):
  fig.add_subplot(51//3,3,i-nb+1)
  plt.imshow(res[i])
  plt.title(liste_combo[i])

# Reconstitution of the image :

# Reconstitution of our final image : 

# We reshape our colors matrix :

len_0 = Z_b_band[0].shape[0]

mat_final = np.empty((len_1,len_2,3))
for i in range(len_1):
  for j in range(len_2):
    mat_final[i][j][0] = mat_res_red_final[i][j]*1e6
    mat_final[i][j][1] = mat_res_green_final[i][j]*1e6
    mat_final[i][j][2] = mat_res_blue_final[i][j]*1e6
mat_final = mat_final.astype('uint8') 
fig = plt.figure(figsize=(15,15))
fig.add_subplot(1,1,1)
plt.imshow(mat_final)
print(" /!\ Before denoising :")

"""#**Test on real images :**"""

#import bands as separate 1 band raster
imagePath10m = '/content/drive/MyDrive/Stage_2022_ACRI-ST/fusion/data/sentinel_2_data/S2B_MSIL2A_20220526T072209_N0400_R063_T38KMG_20220526T094314.SAFE/GRANULE/L2A_T38KMG_A027259_20220526T072203/IMG_DATA/R10m/'
band2 = rasterio.open(imagePath10m+'T38KMG_20220526T072209_B02_10m.jp2', driver='JP2OpenJPEG') #blue
band3 = rasterio.open(imagePath10m+'T38KMG_20220526T072209_B03_10m.jp2', driver='JP2OpenJPEG') #green
band4 = rasterio.open(imagePath10m+'T38KMG_20220526T072209_B04_10m.jp2', driver='JP2OpenJPEG') #red
band8 = rasterio.open(imagePath10m+'T38KMG_20220526T072209_B08_10m.jp2', driver='JP2OpenJPEG') #nir

# The 4 bands of our Sentinel-2 images are : 

plot.show(band2)
print("Blue band")

plot.show(band3)
print("Green band")

plot.show(band4)
print("Red band")

plot.show(band8)
print("Near IR band")

# We are limitated by the computing power, so we reduce the size of the images for the calculations (for each bands):

larg = band4.read(1).shape[1]
long = larg
new_size = 250

band2_S2 = np.empty((new_size,new_size)).astype('uint16')
band2_as_array = band2.read(1).astype('uint16')
for i in range(long-new_size,long):
  for j in range(new_size):
    band2_S2[i-long+new_size][j]=band2_as_array[i][j]

band3_S2 = np.empty((new_size,new_size)).astype('uint16')
band3_as_array = band3.read(1).astype('uint16')
for i in range(long-new_size,long):
  for j in range(new_size):
    band3_S2[i-long+new_size][j]=band3_as_array[i][j]

band4_S2 = np.empty((new_size,new_size)).astype('uint16')
band4_as_array = band4.read(1).astype('uint16')
for i in range(long-new_size,long):
  for j in range(new_size):
    band4_S2[i-long+new_size][j]=band4_as_array[i][j]

band8_S2 = np.empty((new_size,new_size)).astype('uint16')
band8_as_array = band8.read(1).astype('uint16')
for i in range(long-new_size,long):
  for j in range(new_size):
    band8_S2[i-long+new_size][j]=band8_as_array[i][j]

# The 4 images obtained are : 

fig = plt.figure(figsize=(30,30))
fig.add_subplot(2, 2, 1)
plt.imshow(band2_S2)
plt.title("Blue band : ", size = 30)

fig.add_subplot(2, 2, 2)
plt.imshow(band3_S2)
plt.title("Green band : ", size = 30)

fig.add_subplot(2, 2, 3)
plt.imshow(band4_S2)
plt.title("Red band : ", size = 30)

fig.add_subplot(2, 2, 4)
plt.imshow(band8_S2)
plt.title("Near_IR band : ", size = 30)

# The resolution of these images is 250 x 250 pixels

# Now we will artificially deteriorate those Sentinel-2 images to simulate Sentinel-3 images :
new_size = 100

band1_S3 = cv2.resize(band2_S2,dsize=(new_size, new_size))+1500
band2_S3 = cv2.resize(band2_S2,dsize=(new_size, new_size))
band3_S3 = cv2.resize(band3_S2,dsize=(new_size, new_size))
band4_S3 = cv2.resize(band4_S2,dsize=(new_size, new_size))
band5_S3 = cv2.resize(band4_S2,dsize=(new_size, new_size))+1500
band8_S3 = cv2.resize(band8_S2,dsize=(new_size, new_size))


fig = plt.figure(figsize=(30,30))
fig.add_subplot(2, 3, 1)
plt.imshow(band2_S3)
plt.title("Blue band1 : ", size = 30)

fig.add_subplot(2, 3, 3)
plt.imshow(band3_S3)
plt.title("Green band : ", size = 30)

fig.add_subplot(2, 3, 4)
plt.imshow(band4_S3)
plt.title("Red band1 : ", size = 30)

fig.add_subplot(2, 3, 6)
plt.imshow(band8_S3)
plt.title("Near_IR band : ", size = 30)

fig.add_subplot(2, 3, 5)
plt.imshow(band5_S3)
plt.title("Red band2 : ", size = 30)

fig.add_subplot(2, 3, 2)
plt.imshow(band1_S3)
plt.title("Blue band2 : ", size = 30)

# Now we flatten our matrix :
dim_S2 = band2_S2.shape[0]
dim_S3 = band2_S3.shape[0]

S2_flat = []
S3_flat = []

band2_S2_flat = band2_S2.flatten()
band3_S2_flat = band3_S2.flatten()
band4_S2_flat = band4_S2.flatten()
band8_S2_flat = band8_S2.flatten()

band1_S3_flat = band1_S3.flatten()
band2_S3_flat = band2_S3.flatten()
band3_S3_flat = band3_S3.flatten()
band4_S3_flat = band4_S3.flatten()
band5_S3_flat = band5_S3.flatten()
band8_S3_flat = band8_S3.flatten()

S2_flat.append(band2_S2_flat)
S2_flat.append(band3_S2_flat)
S2_flat.append(band4_S2_flat)
S2_flat.append(band8_S2_flat)

S3_flat.append(band1_S3_flat)
S3_flat.append(band2_S3_flat)
S3_flat.append(band3_S3_flat)
S3_flat.append(band4_S3_flat)
S3_flat.append(band5_S3_flat)
S3_flat.append(band8_S3_flat)

S2_flat = np.array(S2_flat)
S2_flat = normalize(S2_flat)

S3_flat = np.array(S3_flat)
S3_flat = normalize(S3_flat)

np.unique(S2_flat)

for i in range(len(S2_flat)):
  for j in range(len(S2_flat[0])):
    if(S2_flat[i][j]) == 1. : S2_flat[i][j] = 0.9999
    if(S2_flat[i][j]) == 0. : S2_flat[i][j] = 0.0001

for i in range(len(S3_flat)):
  for j in range(len(S3_flat[0])):
    if(S3_flat[i][j]) == 1. : S3_flat[i][j] = 0.9999
    if(S3_flat[i][j]) == 0. : S3_flat[i][j] = 0.0001


np.unique(S2_flat)

######## Critère de précision : #########
eps = 1e-1

# Parameters of Etape 1 :

# hyp = unfold(r_sub_matrix_hs,g_sub_matrix_hs)
Lambda_x = 6
Lx = dim_S3**2
n_components = 6

# Parameters of Etape 2 :

Lambda_y = 4
Ly = dim_S2**2
R = np.random.rand(Lambda_y, Lambda_x)
S = np.random.rand(Ly, Lx)
Hy = np.random.rand(n_components, Ly)

print( "Parameters :\n\nLambda_x :", Lambda_x, "\nLx :",Lx, "\nn_components :", n_components, "\nLambda_y :", Lambda_y, "\nLy :",Ly, "\nR :\n", R, "\nS :\n", S, "\nHy :\n", Hy,"\n\nCritère de précision :\n", eps)

Test_final = Algo_CNMF(Lambda_x,Lx,S3_flat,R,S,Hy,S2_flat, steps = True)

Test_final = Algo_CNMF_v2(Lambda_x,Lx,S3_flat,R,S,Test_final[2],S2_flat, Test_final[1], Test_final[3], Test_final[4], steps = True)

# We plots the results :

res = Test_final[0]

len_0 = res.shape[0]
len_1 = band2_S2.shape[0]
len_2 = band2_S2.shape[1]
mat_final_blue1 = res[0].reshape(len_1,len_2)
mat_final_blue2 = res[1].reshape(len_1,len_2)
mat_final_green = res[2].reshape(len_1,len_2)
mat_final_red1 = res[3].reshape(len_1,len_2)
mat_final_red2 = res[4].reshape(len_1,len_2)
mat_final_IR = res[5].reshape(len_1,len_2)

fig = plt.figure(figsize=(30,30))
fig.add_subplot(2, 3, 1)
plt.imshow(mat_final_blue1)
plt.title("Blue band1 : ", size = 30)

fig.add_subplot(2, 3, 2)
plt.imshow(mat_final_blue2)
plt.title("Blue band2 : ", size = 30)

fig.add_subplot(2, 3, 3)
plt.imshow(mat_final_green)
plt.title("Green band : ", size = 30)

fig.add_subplot(2, 3, 4)
plt.imshow(mat_final_red1)
plt.title("Red band1 : ", size = 30)

fig.add_subplot(2, 3, 5)
plt.imshow(mat_final_red2)
plt.title("Red band2 : ", size = 30)

fig.add_subplot(2, 3, 6)
plt.imshow(mat_final_IR)
plt.title("Near_IR band : ", size = 30)

